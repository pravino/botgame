1. The Energy Refill Strategy: "The Hybrid Recharge"
I recommend a Hybrid Model. This combines the "Wait-to-Play" frustration (which makes them value the coins) with a "Daily Reward" high (which keeps them returning).
The Baseline (Time-Based): 1 energy refills every 2 seconds.
Total Refill Time: ~33 minutes for a 1,000 energy tank.
Why: This forces the user to open your Telegram Mini App multiple times a day to "empty their tank."
The Daily High (1 Free "Full Tank"): Give every Bronze member one button per 24 hours that instantly refills their energy to 1,000.
Why: It’s a "dopamine hit." They’ll save it for when they have a spare 5 minutes to go on a "Tapping Spree."
The Upsell (For Profit): Allow them to buy extra Full Tanks for a small amount of "Group Coins" or 1 Telegram Star. This is "Burn Logic" that keeps the coin inflation low.
2. The Tap-to-Earn API Logic (The Middleware)
This API must be high-performance. If 1,000 people tap at once, your database will crash if you aren't careful. We use a "Batch Update" approach.
The Logic:
Instead of sending an API request for every single tap, the Mini App sends a batch of taps every 5–10 seconds.
POST /api/games/tap
typescript
// server/routes/gameRoutes.ts

export const handleTaps = async (req, res) => {
  const { userId, tapCount, timestamp } = req.body;
  
  // 1. GUARDIAN CHECK (Anti-Cheat)
  // If tapCount > (Max Taps Possible in 10s), flag as BOT
  if (tapCount > 150) { 
    await db.flagUser(userId, "SUSPICIOUS_TAP_SPEED");
    return res.status(403).json({ error: "Slow down, Champ!" });
  }

  // 2. ENERGY CHECK
  const user = await db.getUser(userId);
  if (user.currentEnergy < tapCount) {
    return res.status(400).json({ error: "Out of Energy!" });
  }

  // 3. ATOMIC UPDATE (The Ledger)
  // We subtract energy and add coins in ONE transaction
  await db.transaction(async (tx) => {
    await tx.update(users)
      .set({ 
        current_energy: user.current_energy - tapCount,
        total_lifetime_coins: user.total_lifetime_coins + tapCount 
      })
      .where(eq(users.id, userId));

    await tx.insert(daily_activity)
      .values({ user_id: userId, taps_today: tapCount, date: new Date() })
      .onConflictDoUpdate({
        target: [daily_activity.user_id, daily_activity.date],
        set: { taps_today: sql`taps_today + ${tapCount}` }
      });
  });

  res.json({ newBalance: user.total_lifetime_coins + tapCount, remainingEnergy: user.current_energy - tapCount });
};
Use code with caution.

3. Why this protects your $15,000 Profit
Database Efficiency: By using onConflictDoUpdate, the daily_activity table stays lean. It only has 1,000 rows (one for each user) per day.
The "Energy Wall": By limiting energy, you ensure that even a guy with an auto-clicker is physically capped by his energy tank. He can't steal the whole 50% Tap Pot because he has to wait for his tank to refill just like everyone else.
Engagement Metrics: The "1 energy per 2 seconds" refill means your Group Activity stays high 24/7. When potential sponsors or new members see 1,000 people constantly "online," the perceived value of your group skyrockets.
Summary Checklist for this Step:
Frontend: Build the "Coin" that animates and vibrates on tap.
Backend: Implement the POST /api/games/tap with the Guardian speed-check.
Cron Job: Ensure energy refills for everyone every 2 seconds (or calculate "Time Since Last Tap" on login to save server resources).